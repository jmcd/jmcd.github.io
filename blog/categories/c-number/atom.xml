<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C# | jmcd.io]]></title>
  <link href="http://jmcd.github.io/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://jmcd.github.io/"/>
<<<<<<< HEAD
  <updated>2015-03-19T10:44:13+00:00</updated>
=======
  <updated>2015-02-28T08:25:55+00:00</updated>
>>>>>>> 5af33b1e15f225bfba01899c9a3b62380c83fdf3
  <id>http://jmcd.github.io/</id>
  <author>
    <name><![CDATA[John McDowall]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Selecting Denormalized Child Nodes and Parents From Tree With Linq]]></title>
    <link href="http://jmcd.github.io/blog/2009/08/05/selecting-denormalized-child-nodes-and-parents-from-tree-with-linq/"/>
    <updated>2009-08-05T00:00:00+01:00</updated>
    <id>http://jmcd.github.io/blog/2009/08/05/selecting-denormalized-child-nodes-and-parents-from-tree-with-linq</id>
    <content type="html"><![CDATA[<p>Problem: You have a collection of objects.&#160; Each object has a number of children.&#160; You want all the children matching a criteria, AND the parent.&#160; The child does not reference the parent.</p>

<p>Solution: You can use Linq to</p>

<ul>
<li>From the context of all the parents, select all the children with the “SelectMany” method.</li>
<li>Construct and select instances of an anonymous type combining the parent and child.&#160; (You can do this because the context is that of the parent.)</li>
<li>Apply your filtering criteria.</li>
</ul>


<p>Example: Select the five most recently modified children (and parent)</p>

<pre><code class="csharp">class Program
{
    static void Main()
    {
        var allParents = new StupidFactory().ConstructParents(100);

        var fiveMostRecentChildrenAndParent = allParents
            .SelectMany(parent =&gt; parent.Children)
            .Select(child =&gt; new { Child = child, Parent = allParents.Where(parent =&gt; parent.Children.Contains(child)).Single() })
            .OrderByDescending(anonymousCombo =&gt; anonymousCombo.Child.LastModified)
            .Take(5);

        foreach (var childAndParent in fiveMostRecentChildrenAndParent)
        {
            Console.WriteLine("{0} modified on {1} (belongs to {2})", childAndParent.Child.Name, childAndParent.Child.LastModified.ToShortDateString(), childAndParent.Parent.Name);
        }
    } 
}


public abstract class Entity
{
    public string Name;
}

public class Parent : Entity
{
    public List&lt;Child&gt; Children = new List&lt;Child&gt;();
}

public class Child : Entity
{
    public DateTime LastModified;
}

public class StupidFactory
{
    private readonly Random _random = new Random();
    private int _childCount;
    private int _parentCount;

    private Child ConstructChild()
    {
        return new Child { Name = "Child_" + _childCount++, LastModified = DateTime.Now.AddDays(-_random.Next(0, 365)) };
    }

    private Parent ConstructParent()
    {
        var result = new Parent { Name = "Parent_" + _parentCount++ };
        var childCount = _random.Next(0, 11);
        for (var i = 0; i &lt; childCount; i++)
        {
            result.Children.Add(ConstructChild());
        }
        return result;
    }

    public IList&lt;Parent&gt; ConstructParents(int count)
    {
        var result = new List&lt;Parent&gt;();
        for (var i = 0; i &lt; count; i++)
        {
            result.Add(ConstructParent());
        }
        return result;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Caching the Result of Arbitrary Function Calls]]></title>
    <link href="http://jmcd.github.io/blog/2009/08/05/caching-the-result-of-arbitrary-function-calls/"/>
    <updated>2009-08-05T00:00:00+01:00</updated>
    <id>http://jmcd.github.io/blog/2009/08/05/caching-the-result-of-arbitrary-function-calls</id>
    <content type="html"><![CDATA[<p>Here is the approach I took to performing the result of a method call, which is done in a reusable way which may be interesting.  Instead of calling my method normally like this:</p>

<pre><code class="csharp">var service = new MyService();
var time = service.GetTime();
</code></pre>

<p>I wrap that call in a call to the cache:</p>

<pre><code class="csharp">var service = new MyService();
var time = cache.Get(x =&gt; x.GetTime(), service, tenSeconds);
</code></pre>

<p>Inside the Cache implementation I have a method Get, which wraps up the method call in a wrapping function, then passes this parcel to the InvokeOrGetFromCache method:</p>

<p>There is a variant of “Get” for every variant of Func&lt;>.</p>

<p>The InvokeOrGetFromCache is the meat of the cache class.&#160; It controls access two the actual store of objects (a dictionary of function to result), and a collection of pending functions (a hashset).</p>

<p>When requesting a result for a function from the cache, the pending set is first checked.&#160; If the job is already pending, the requesting thread yields until the job is done.</p>

<p>When a function’s result is not present in the cache, it is added to the pending functions set.&#160; The function is invoked, its result is added to the cache, then the function is removed from the pending set.</p>

<p><em>NB</em> As you can see, the key to the cache is just the function itself – this means that calls with different instances/values will result in the same result.&#160; This is fine for my purposes, but may not be OK for you.&#160; In this case it would be fairly straightforward to build a new key which incorporated the values as well as the function itself.</p>

<pre><code class="csharp">public class Cache
{
    private readonly IDictionary&lt;object, CachedItem&gt; _registry = new Dictionary&lt;object, CachedItem&gt;();
    private readonly ICollection&lt;object&gt; _pending = new HashSet&lt;object&gt;();

    public TResult Get&lt;T, TResult&gt;(Func&lt;T, TResult&gt; func, T t, TimeSpan maximumAge)
    {
        return InvokeOrGetFromCache(func, maximumAge, () =&gt; func.Invoke(t));
    }

    public TResult Get&lt;T1, T2, TResult&gt;(Func&lt;T1, T2, TResult&gt; func, T1 t1, T2 t2, TimeSpan maximumAge)
    {
        return InvokeOrGetFromCache(func, maximumAge, () =&gt; func.Invoke(t1, t2));
    }

    public TResult Get&lt;T1, T2, T3, TResult&gt;(Func&lt;T1, T2, T3, TResult&gt; func, T1 t1, T2 t2, T3 t3, TimeSpan maximumAge)
    {
        return InvokeOrGetFromCache(func, maximumAge, () =&gt; func.Invoke(t1, t2, t3));
    }

    public TResult Get&lt;T1, T2, T3, T4, TResult&gt;(Func&lt;T1, T2, T3, T4, TResult&gt; func, T1 t1, T2 t2, T3 t3, T4 t4, TimeSpan maximumAge)
    {
        return InvokeOrGetFromCache(func, maximumAge, () =&gt; func.Invoke(t1, t2, t3, t4));
    }

    private TResult InvokeOrGetFromCache&lt;TResult&gt;(object cacheKey, TimeSpan maximumAge, Func&lt;TResult&gt; wrapperFunc)
    {
        var now = DateTime.Now;

        WaitForPendingInvokeToComplete(cacheKey);

        lock(_registry)
        {
            if (_registry.ContainsKey(cacheKey))
            {
                var result = _registry[cacheKey];
                if (result.TimeOfConstruction.Add(maximumAge) &gt; now)
                {
                    return (TResult) result.Value;
                }
            }
        }

        return Invoke(cacheKey, now, wrapperFunc);
    }

    private TResult Invoke&lt;TResult&gt;(object cacheKey, DateTime now, Func&lt;TResult&gt; wrapperFunc)
    {
        _pending.Add(cacheKey);
        var value = wrapperFunc.Invoke();
        _registry[cacheKey] = new CachedItem(now, value);
        _pending.Remove(cacheKey);
        return value;
    }

    private void WaitForPendingInvokeToComplete(object cacheKey)
    {
        while (_pending.Contains(cacheKey))
        {
            Thread.Sleep(0);
        }
    }

    private class CachedItem
    {
        public CachedItem(DateTime timeOfConstruction, object value)
        {
            TimeOfConstruction = timeOfConstruction;
            Value = value;
        }

        public DateTime TimeOfConstruction { get; private set; }
        public object Value { get; private set; }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Expression Trees to Avoid String Literal References]]></title>
    <link href="http://jmcd.github.io/blog/2009/06/30/using-expression-trees-to-avoid-string-literal-references/"/>
    <updated>2009-06-30T00:00:00+01:00</updated>
    <id>http://jmcd.github.io/blog/2009/06/30/using-expression-trees-to-avoid-string-literal-references</id>
    <content type="html"><![CDATA[<p>Often a developer will want to mirror the names of properties or methods of a class in some related dynamic resource that needs to bind to named members of the class. This happens a lot in user interface and serialization scenarios.</p>

<p>For example, a user interface may need to populate the value of a text-box with a value dynamically looked up from a property on an instance of a class.  Typically, this is done with a hard-coded string literal.</p>

<p>To avoid using hard-coded member names, expression trees can be used to define members, then utility code can translate that tree to a string.  The advantage here is that refactoring is pretty much guaranteed to work, and you get compile time checking.</p>

<p>So, lets say I have the following class, and I am interested in writing the the names of the members to the console.</p>

<pre><code class="csharp">class MyType
{
    public string AStringProperty { get; set; }

    public object GetAnObject()
    {
        return new object();
    }

    public int GetAnInt(string a1, string a2)
    {
        return 0;
    }
}
</code></pre>

<p>With a small amount of utility code, I can achieve my goal without string literals or resorting to reflection.</p>

<pre><code class="csharp">Console.WriteLine(Name.Of&lt;MyType&gt;(x =&gt; x.AStringProperty)); 
Console.WriteLine(Name.Of&lt;MyType&gt;(x =&gt; x.GetAnObject())); 
Console.WriteLine(Name.Of&lt;MyType&gt;(x =&gt; x.GetAnInt(null, null)));
</code></pre>

<p>Which results in console output:</p>

<pre><code class="csharp">AStringProperty 
GetAnObject 
GetAnInt 
</code></pre>

<p>Utility Code The <i>Name</i> class has a single static method <i>Of</i>, which uses another the </i>ExpressionFinder</i> class to work out the member or method.</p>

<pre><code class="csharp">class Name
{
    public static string Of&lt;T&gt;(Expression&lt;Func&lt;T, object&gt;&gt; expr)
    {
        return ExpressionMemberFinder.FindMemberOrNull(expr).Name;
    }
}

class ExpressionMemberFinder
{
    public static MemberInfo FindMemberOrNull(Expression expression)
    {
        switch (expression.NodeType)
        {
            case ExpressionType.Convert:
                return FindMemberOrNull(((UnaryExpression) expression).Operand);
            case ExpressionType.Lambda:
                return FindMemberOrNull(((LambdaExpression) expression).Body);
            case ExpressionType.Call:
                return ((MethodCallExpression) expression).Method;
            case ExpressionType.MemberAccess:
                return ((MemberExpression) expression).Member;
            default:
                return null;
        }
    }
}
</code></pre>

<p>It&rsquo;s worth noting that the only type of expression tree we can work on is one that ends in a single method-call or member-access.  It doesn&rsquo;t make any sense to work on a tree with branches or multiple leaf nodes.</p>

<p>Lets examine what happens in the FindMemberOrNull method by looking at three kinds of tree that we can handle.</p>

<h2>Behaviour #1, Finding a Property Access</h2>

<p>Name.Of&lt;MyType&gt;(x =&gt; x.AStringProperty));</p>

<ul>
<li>FindMemberOrNull is called with a lambda {x =&gt; x.AStringProperty}</li>
<li>FindMemberOrNull is called from within itself with the lambda&rsquo;s body, a member-expression {x =&gt; x.AStringProperty}</li>
<li>The member-expression&rsquo;s member is returned</li>
</ul>


<h2>Behaviour #2, Finding a Method That Returns an Object</h2>

<p>Name.Of&lt;MyType&gt;(x =&gt; x.GetAnObject()));</p>

<ul>
<li>FindMemberOrNull is called with a lambda {x =&gt; x.GetAnObject() }</li>
<li>FindMemberOrNull is called from within itself with the lambda&rsquo;s body, a method-call-expression {x =&gt; x.GetAnObject()}</li>
<li>The method-call-expression&rsquo;s method is returned</li>
</ul>


<h2>Behaviour #3, Finding a Method That Returns an Something Other Than an Object</h2>

<p>Name.Of&lt;MyType&gt;(x.GetAnInt(null, null))); Slightly more interesting behaviour here.</p>

<ul>
<li>As the FindMemberOrNull method accepts a expression describing a function that returns System.Object, the compiler automatically wraps the expression in a unary-expression which converts from Expression&lt;Func&lt;MyType, int&gt;&gt; to Expression&lt;Func&lt;MyType, object&gt;&gt;.  - NICE!</li>
<li>FindMemberOrNull is called with a lambda {x =&gt; Convert(x.GetAnInt(null, null))}</li>
<li>FindMemberOrNull is called from within itself with the lambda&rsquo;s body, a unary-expression {x =&gt;Convert(x.GetAnInt(null, null))}</li>
<li>FindMemberOrNull is called from within itself with the unary-expression&rsquo;s operand, a method-call-expression {x =&gt; x.GetAnInt(null, null)}</li>
<li>The method-call-expression&rsquo;s method is returned</li>
</ul>

]]></content>
  </entry>
  
</feed>
