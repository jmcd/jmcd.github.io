<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocoa Touch | jmcd.io]]></title>
  <link href="http://jmcd.io/blog/categories/cocoa-touch/atom.xml" rel="self"/>
  <link href="http://jmcd.io/"/>
  <updated>2015-04-06T17:36:46+01:00</updated>
  <id>http://jmcd.io/</id>
  <author>
    <name><![CDATA[John McDowall]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My Two Favourite Parts of the iOS 7 SDK]]></title>
    <link href="http://jmcd.io/blog/2013/09/18/my-two-favourite-parts-of-the-ios7-sdk/"/>
    <updated>2013-09-18T00:00:00+01:00</updated>
    <id>http://jmcd.io/blog/2013/09/18/my-two-favourite-parts-of-the-ios7-sdk</id>
    <content type="html"><![CDATA[<h2>Notifications and background downloading</h2>

<p>Prior to iOS 7, an inactive app is ignorant of notifications sent to the device. With iOS 7, an app can register to be woken when a notification arrives, in order to download data in the background. Imagine the you have a messaging app on your iOS 6 phone:</p>

<ul>
<li>Receive notification of new message</li>
<li>You tap notification to launch app</li>
<li><strong>You wait</strong> for app to connect to its server and download the message</li>
</ul>


<p>With iOS 7:</p>

<ul>
<li>Receive notification of new message</li>
<li>App starts up in the background and downloads message from its server</li>
<li>You tap notification to launch app, and <strong>the message is already there</strong></li>
</ul>


<p>An app running on iOS 7 can also request that the system give it regular background execution time to perform downloads. When you launch the Facebook app in the future, you may find that you do not have to wait for new posts to be downloaded, because the app has already downloaded them in the background.</p>

<p>If an app takes too long to download data in the background, uses too much power or data it will be given less opportunity to download in the future.</p>

<h2>Sprite Kit</h2>

<p>Most developers have an idea for a game, but have no idea how to write it. Game development is a whole different world from the type of business or web work that developers tend to do.</p>

<p>Sprite Kit is a framework that assists a developer creating 2D games by providing game-loop, facilities for graphics rendering, physics simulations and manipulation of in game objects. In short, it takes a lot of the grunt work out of creating a game.</p>

<p>Here I wrote a very small app using Sprite Kit. You tap the screen to set a car driving from the left of the screen. The car accelerates up to a maximum of 30mph, and maybe crashes into other cars. <a href="https://gist.github.com/jmcd/6605801#file-myscene-m">The code I had to write is less than 80 lines long</a>, Sprite Kit handles all the heavy lifting, leaving the developer free to concentrate on game logic.</p>

<p><video  preload='metadata' controls ><source src='/vid/SpriteKitDemo.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'></video></p>

<p>Expect to see a lot of developers writing games where previously the barrier of entry was too high.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling MKMapView Annotation Pins on the Same Coordinate]]></title>
    <link href="http://jmcd.io/blog/2013/01/10/handling-annotation-pins-on-the-same-coordinate/"/>
    <updated>2013-01-10T00:00:00+00:00</updated>
    <id>http://jmcd.io/blog/2013/01/10/handling-annotation-pins-on-the-same-coordinate</id>
    <content type="html"><![CDATA[<p>A component of a project I am working on displays shop locations on a map. A problem arises when the shops are located at a shopping centre or mall - the shops are invariably geo-coded to the same latitude-longitude coordinates.</p>

<p>When the shops have the same coordinates, the annotations (pins) display in the exact same location on the map. This gives the appearance of there only being one pin, and indeed, the user can only tap one pin.</p>

<p>To overcome this, we implemented a routine to re-place the pins at new coordinates surrounding the contested coordinate.</p>

<p><img src="/img/Screen-Shot-2013-01-10-at-14.32.11.png" title="pins surrounding coord" ></p>

<p><em>tl;dr get the full <a href="https://gist.github.com/4502302">code</a>.</em></p>

<p>First we group the annotations by coordinate.</p>

<pre><code class="objc">for (id&lt;MKAnnotation&gt; pin in annotations) {

    CLLocationCoordinate2D coordinate = pin.coordinate;
    NSValue *coordinateValue = [NSValue valueWithBytes:&amp;#038;coordinate objCType:@encode(CLLocationCoordinate2D)];

    NSMutableArray *annotationsAtLocation = coordinateValuesToAnnotations[coordinateValue];
    if (!annotationsAtLocation) {
        annotationsAtLocation = [NSMutableArray array];
        coordinateValuesToAnnotations[coordinateValue] = annotationsAtLocation;
    }

    [annotationsAtLocation addObject:pin];
}
</code></pre>

<p>This routine produces a dictionary keyed on <code>NSValue</code>s containing a copy of the coordinate (you can&rsquo;t key a <code>NSDictionary</code> on a c-type). The value of a entry in the dictionary is a <code>NSArray</code> of annotations at that coordinate.</p>

<p>You can see this only matches on exactly equal coordinates, but it would be relatively straightforward to group on coordinates that were close by calculating the distance between them.</p>

<p>Next we enumerate the dictionary looking for locations that have more than one annotation. When we find one, we reposition the annotations.</p>

<pre><code class="objc">double distance = 3 * annotations.count / 2.0;
double radiansBetweenAnnotations = (M_PI * 2) / annotations.count;

for (int i = 0; i &lt; annotations.count; i++) {

    double heading = radiansBetweenAnnotations * i;
    CLLocationCoordinate2D newCoordinate = [self calculateCoordinateFrom:coordinate onBearing:heading atDistance:distance];

    id &lt;MKAnnotation&gt; annotation = annotations[i];
    annotation.coordinate = newCoordinate;
}
</code></pre>

<p>The pins are arranged in a circle around the contested point by dividing the circle by the number of contesting annotations. You can see that the distance from the contested coordinate to the new coordinate is a function of the number of annotations contesting - if there are few pins contesting the coordinate, then we have space to place the pins close to the coordinate.</p>

<p>Finally, the new coordinate is calculated using an implementation of the function from this excellent resource: <a href="http://www.movable-type.co.uk/scripts/latlong.html">Destination point given distance and bearing from start point</a>.</p>

<pre><code class="objc">+ (CLLocationCoordinate2D)calculateCoordinateFrom:(CLLocationCoordinate2D)coordinate onBearing:(double)bearingInRadians atDistance:(double)distanceInMetres {

    double coordinateLatitudeInRadians = coordinate.latitude * M_PI / 180;
    double coordinateLongitudeInRadians = coordinate.longitude * M_PI / 180;

    double distanceComparedToEarth = distanceInMetres / 6378100;

    double resultLatitudeInRadians = asin(sin(coordinateLatitudeInRadians) * cos(distanceComparedToEarth) + cos(coordinateLatitudeInRadians) * sin(distanceComparedToEarth) * cos(bearingInRadians));
    double resultLongitudeInRadians = coordinateLongitudeInRadians + atan2(sin(bearingInRadians) * sin(distanceComparedToEarth) * cos(coordinateLatitudeInRadians), cos(distanceComparedToEarth) - sin(coordinateLatitudeInRadians) * sin(resultLatitudeInRadians));

    CLLocationCoordinate2D result;
    result.latitude = resultLatitudeInRadians * 180 / M_PI;
    result.longitude = resultLongitudeInRadians * 180 / M_PI;
    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
