<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Expressions | jmcd.io]]></title>
  <link href="http://jmcd.io/blog/categories/expressions/atom.xml" rel="self"/>
  <link href="http://jmcd.io/"/>
  <updated>2015-03-19T10:52:31+00:00</updated>
  <id>http://jmcd.io/</id>
  <author>
    <name><![CDATA[John McDowall]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Expression Trees to Avoid String Literal References]]></title>
    <link href="http://jmcd.io/blog/2009/06/30/using-expression-trees-to-avoid-string-literal-references/"/>
    <updated>2009-06-30T00:00:00+01:00</updated>
    <id>http://jmcd.io/blog/2009/06/30/using-expression-trees-to-avoid-string-literal-references</id>
    <content type="html"><![CDATA[<p>Often a developer will want to mirror the names of properties or methods of a class in some related dynamic resource that needs to bind to named members of the class. This happens a lot in user interface and serialization scenarios.</p>

<p>For example, a user interface may need to populate the value of a text-box with a value dynamically looked up from a property on an instance of a class.  Typically, this is done with a hard-coded string literal.</p>

<p>To avoid using hard-coded member names, expression trees can be used to define members, then utility code can translate that tree to a string.  The advantage here is that refactoring is pretty much guaranteed to work, and you get compile time checking.</p>

<p>So, lets say I have the following class, and I am interested in writing the the names of the members to the console.</p>

<pre><code class="csharp">class MyType
{
    public string AStringProperty { get; set; }

    public object GetAnObject()
    {
        return new object();
    }

    public int GetAnInt(string a1, string a2)
    {
        return 0;
    }
}
</code></pre>

<p>With a small amount of utility code, I can achieve my goal without string literals or resorting to reflection.</p>

<pre><code class="csharp">Console.WriteLine(Name.Of&lt;MyType&gt;(x =&gt; x.AStringProperty)); 
Console.WriteLine(Name.Of&lt;MyType&gt;(x =&gt; x.GetAnObject())); 
Console.WriteLine(Name.Of&lt;MyType&gt;(x =&gt; x.GetAnInt(null, null)));
</code></pre>

<p>Which results in console output:</p>

<pre><code class="csharp">AStringProperty 
GetAnObject 
GetAnInt 
</code></pre>

<p>Utility Code The <i>Name</i> class has a single static method <i>Of</i>, which uses another the </i>ExpressionFinder</i> class to work out the member or method.</p>

<pre><code class="csharp">class Name
{
    public static string Of&lt;T&gt;(Expression&lt;Func&lt;T, object&gt;&gt; expr)
    {
        return ExpressionMemberFinder.FindMemberOrNull(expr).Name;
    }
}

class ExpressionMemberFinder
{
    public static MemberInfo FindMemberOrNull(Expression expression)
    {
        switch (expression.NodeType)
        {
            case ExpressionType.Convert:
                return FindMemberOrNull(((UnaryExpression) expression).Operand);
            case ExpressionType.Lambda:
                return FindMemberOrNull(((LambdaExpression) expression).Body);
            case ExpressionType.Call:
                return ((MethodCallExpression) expression).Method;
            case ExpressionType.MemberAccess:
                return ((MemberExpression) expression).Member;
            default:
                return null;
        }
    }
}
</code></pre>

<p>It&rsquo;s worth noting that the only type of expression tree we can work on is one that ends in a single method-call or member-access.  It doesn&rsquo;t make any sense to work on a tree with branches or multiple leaf nodes.</p>

<p>Lets examine what happens in the FindMemberOrNull method by looking at three kinds of tree that we can handle.</p>

<h2>Behaviour #1, Finding a Property Access</h2>

<p>Name.Of&lt;MyType&gt;(x =&gt; x.AStringProperty));</p>

<ul>
<li>FindMemberOrNull is called with a lambda {x =&gt; x.AStringProperty}</li>
<li>FindMemberOrNull is called from within itself with the lambda&rsquo;s body, a member-expression {x =&gt; x.AStringProperty}</li>
<li>The member-expression&rsquo;s member is returned</li>
</ul>


<h2>Behaviour #2, Finding a Method That Returns an Object</h2>

<p>Name.Of&lt;MyType&gt;(x =&gt; x.GetAnObject()));</p>

<ul>
<li>FindMemberOrNull is called with a lambda {x =&gt; x.GetAnObject() }</li>
<li>FindMemberOrNull is called from within itself with the lambda&rsquo;s body, a method-call-expression {x =&gt; x.GetAnObject()}</li>
<li>The method-call-expression&rsquo;s method is returned</li>
</ul>


<h2>Behaviour #3, Finding a Method That Returns an Something Other Than an Object</h2>

<p>Name.Of&lt;MyType&gt;(x.GetAnInt(null, null))); Slightly more interesting behaviour here.</p>

<ul>
<li>As the FindMemberOrNull method accepts a expression describing a function that returns System.Object, the compiler automatically wraps the expression in a unary-expression which converts from Expression&lt;Func&lt;MyType, int&gt;&gt; to Expression&lt;Func&lt;MyType, object&gt;&gt;.  - NICE!</li>
<li>FindMemberOrNull is called with a lambda {x =&gt; Convert(x.GetAnInt(null, null))}</li>
<li>FindMemberOrNull is called from within itself with the lambda&rsquo;s body, a unary-expression {x =&gt;Convert(x.GetAnInt(null, null))}</li>
<li>FindMemberOrNull is called from within itself with the unary-expression&rsquo;s operand, a method-call-expression {x =&gt; x.GetAnInt(null, null)}</li>
<li>The method-call-expression&rsquo;s method is returned</li>
</ul>

]]></content>
  </entry>
  
</feed>
